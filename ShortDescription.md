# Краткое описание #

DataScraper (дальше буду называть ее ДС) создана для того, чтобы можно было вытянуть нужную информацию с сайта, реструктуризировать ее и сложить в нужном формате в нужное место.

У ДС очень простой принцип работы - из типовых действий выстроить сценарий, который будет выполнен программой. Сверху на инструментальной панели расположены кнопки типовых действий, их всего 10:

|![http://datascraper.googlecode.com/svn/wiki/dsa01.png](http://datascraper.googlecode.com/svn/wiki/dsa01.png)	|Установить текст	|Игнорирует прямой поток от своего родителя, и передает потомкам то, что установлено у него в свойстве "Text"|
|:-------------------------------------------------------------------------------------------------------------|:----------------|:-----------------------------------------------------------------------------------------------------------|
|![http://datascraper.googlecode.com/svn/wiki/dsa02.png](http://datascraper.googlecode.com/svn/wiki/dsa02.png)	|Скачать страницу	|Пытается загрузить WEB-страницу по указанному на входе адресу, на выходе - содержимое страницы              |
|![http://datascraper.googlecode.com/svn/wiki/dsa03.png](http://datascraper.googlecode.com/svn/wiki/dsa03.png)	|Скачать эту страницу и перейти на следующую	| Загружает страницу аналогично предыдущему действию, но после того как получило содержимое ищет в нем ссылку на следующую страницу, в соответствии с указанным в свойствах рег.выражения. <br />Организует цикл, в котором каждая страница скачивается, передается потомкам, после чего скачивается следующая страница.|
|![http://datascraper.googlecode.com/svn/wiki/dsa04.png](http://datascraper.googlecode.com/svn/wiki/dsa04.png)	|Скачать бинарные данные (например, картинки и пр. мультимедию)	|На входе - адрес бинарного файла, на выходе потока - имя файла, в который сохранили данные.                 |
|![http://datascraper.googlecode.com/svn/wiki/dsa05.png](http://datascraper.googlecode.com/svn/wiki/dsa05.png)	|Найти	           | Поиск подстрок во входном потоке при помощи рег.выражений. <br /> Если совпадений несколько, то действие образует цикл, в котором передает каждое совпадание последовательно каждому потомку. <br /> Группы, выделенные в регулярном выражении круглыми скобками (), подставляются в FormatString в виде {1},{2} и т.д. <br /> {0} - подстрока соответствующая всему регулярному выражению |
|![http://datascraper.googlecode.com/svn/wiki/dsa06.png](http://datascraper.googlecode.com/svn/wiki/dsa06.png)	|Заменить	        |Замена подстрок в прямом потоке с использованием регулярных выражений.                                      |
Важно заметить, что формат подстановки групп отличается от компонента "Найти", здесь группы подставляются не в виде "{}", а в виде $1, $2 и т.д.,
$0 - соответствует всему регулярному выражению.
Понимаю, что надо бы привести к единому виду, но руки не доходят.
|![http://datascraper.googlecode.com/svn/wiki/dsa07.png](http://datascraper.googlecode.com/svn/wiki/dsa07.png)	|Сохранить в памяти	|Записывает в переменную с именем, указанным в свойстве "label" прямой или обратный поток                    |
|![http://datascraper.googlecode.com/svn/wiki/dsa08.png](http://datascraper.googlecode.com/svn/wiki/dsa08.png)	|Достать из памяти	|Игнорирует вход прямого потока, читает из переменной с именем, указанным в свойстве "label" содержимое и записывает его в прямой поток|
|![http://datascraper.googlecode.com/svn/wiki/dsa09.png](http://datascraper.googlecode.com/svn/wiki/dsa09.png)	|Сохранить на диске	|Сохраняет поток в файле                                                                                     |
|![http://datascraper.googlecode.com/svn/wiki/dsa10.png](http://datascraper.googlecode.com/svn/wiki/dsa10.png)	|Сформировать дату	|Иногда требуется в параметре Get запроса указать дату, это служить именно для этого. Похож на действие "Установить текст", только вместо текста - отформатированная дата|

Действия связываются друг с другом в виде дерева, каждый узел может содержать потомков, которые получают от него информацию для обработки. Каждое действие обрабатывает информацию по-своему, в соответствии со своей функциональностью и установленными свойствами.

Каждый узел дерева - это действие, далее я буду писать или "действие" или "узел, родитель, потомок" в зависимости от контекста, но по смыслу - это одно и то же.

## Организация текстовых потоков ##

Не будет преувеличением сказать, что без понимания того как через узлы дерева проходят информационные потоки нельзя будет сделать даже простейший сценарий.

**ВАЖНО**: через каждое действие проходит два информационных потока: прямой - от родителя к потомками и обратный - от потомков к родителю.

Поток - это простой текст, передаваемый узлами дерева друг другу в соответствии от расположения в иерархии. Я буду чаще говорит "поток", потому что так нагляднее прохождение информации от одного действия к другому.

Как правило, действия меняют прямой поток. Так на входе узел получает от родителя какой-то текст, а на выходе передает потомкам то, что получилось после обработки. Иногда я буду использовать такие термины как ВХОД, ВЫХОД и РЕЗУЛЬТАТ.
ВХОД - это то, что получает узел в прямом потоке от своего родителя
ВЫХОД - это то, что передает узел в прямом потоке своим потомкам
РЕЗУЛЬТАТ - это то, что проходит в обратном потоке

Работает простая рекурсия, родитель передает результаты своей работы (прямой поток) первому потомку, ждет пока тот обработает полученное и вернет результат (обратный поток). Как только это произошло, родитель записывает полученное содержимое в свой обратный поток, и повторяет то же самое со своим вторым, третьим и др. потомками.
В результате он накапливает в своем обратном потоке содержимое из обратных потоков своих детей, и после того как последний потомок вернул результаты работы - сообщает своему родителю о том, что закончил работу и передает ему обратный поток.

ПРИМЕР.

ЗАДАНИЕ.
Нужно вытянуть из WEB странички какой-то текст, расположенный в известном месте, а потом сохранить его в файле.

РЕШЕНИЕ.
Берем 4 действия и последовательно связываем их так, что каждое последующее - потомок предыдущего:

|1|![http://datascraper.googlecode.com/svn/wiki/dsa01.png](http://datascraper.googlecode.com/svn/wiki/dsa01.png)| В свойствах этого действия указываем адрес нужной страницы|
|:|:------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------|
|2|![http://datascraper.googlecode.com/svn/wiki/dsa02.png](http://datascraper.googlecode.com/svn/wiki/dsa02.png)| Собственно скачиваем                                      |
|3|![http://datascraper.googlecode.com/svn/wiki/dsa05.png](http://datascraper.googlecode.com/svn/wiki/dsa05.png)| Ищем то, что нам нужно                                    |
|4|![http://datascraper.googlecode.com/svn/wiki/dsa09.png](http://datascraper.googlecode.com/svn/wiki/dsa09.png)| Сохраняем в файл, имя которого задано в свойстве "FileName"|

В программе можно увидеть содержимое потоков каждого узла на вкладках:
  * input - содержимое прямого потока на входе в узел
  * output - содержимое прямого потока на выходе из узла
  * result - содержимое обратного потока

## Многопоточность ##

Внимание! Мнопоточность поддерживается только в windows-программах, в PHP классах многопоточность не реализована.

Организовать параллельное выполнение достаточно просто: в действии "Найти" нужно установить значение "true" у свойства MultiThreading.

Пример использования: есть каталог, для которого нужно организовать параллельную обработку разделов. Загружаем корневую страницу, затем при помощи действия "Найти" в HTML разметке выделяем разделы. В итоге, получается цикл по разделам. Если в свойствах "Найти" указать многопоточность, то каждая итерация цикла будет запущена в отдельном потоке. При этом, действие "Найти" будет ждать завершения всех потоков и только после этого передаст управление дальше.

Обратите внимание, чтобы действия "Сохранить на диске" не запускались параллельно! Иначе возникнет конкуренция потоков за файл, что приведет к ошибкам в работе.